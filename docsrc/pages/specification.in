<title>SQLite Requirements</title>

<h2>SQLite Specifications</h2>

<p>This document is a work in progress.</p>

<p>The goal of this document is to provide an precise and exact
definition of what SQLite does, how it works, and what to expect
from SQLite for any given input.  When completed, this document
will become the authoritative reference for using SQLite.</p>

<h3>The C/C++ Interface</h3>

<table cellspacing="20" border="0">

<tcl>
# Initialization the specification array
#
unset -nocomplain spec

# Extract specifications from the sqlite3.h header file
#
set in [open sqlite3.h] 
set title {}       ;# title of a section of interface definition
set code {}        ;# C code of the definition
set phase 0        ;# Phase used by the parser 
set dcnt 0         ;# Number of individual declarations
set lineno 0       ;# input file line number
set spectag {}     ;# Current specification tag number
set specbody {}    ;# Text of current specification

proc endspec {} {
  global spectag specbody spec
  if {$spectag!="" && $specbody!=""} {
    if {[info exists spec($spectag)]} {
       puts stderr "WARNING: duplicate specification: $spectag"
    }
    set body [string map \
          {<todo> {<font color="red">(TODO: } </todo> )</font>} $specbody]
    set spec($spectag) [string trim $body]
  }
  set spectag {}
  set specbody {}
}
proc beginspec {tag body} {
  global spectag specbody
  endspec
  set spectag $tag
  set specbody $body
}

# Read sqlite3.h line by line and extract interface definition
# information.
#
while {![eof $in]} {
  set line [gets $in]
  incr lineno
  if {$phase==0} {
    # Looking for the CAPI3REF: keyword
    if {[regexp {^\*\* CAPI3REF: +(.*)} $line all tx]} {
      set title $tx
      set title_lineno $lineno
      set phase 1
    }
  } elseif {$phase==1} {
    if {[string range $line 0 1]=="**"} {
      set lx [string trim [string range $line 3 end]]
      if {[regexp {^COVENANTS:$} $lx]} {
        set phase 2
      } elseif {[regexp {^LIMITATIONS:$} $lx]} {
        set phase 2
      }
    } elseif {[string range $line 0 1]=="*/"} {
      set phase 3
    }
  } elseif {$phase==2} {
    if {[string range $line 0 1]=="**"} {
      set lx [string trim [string range $line 3 end]]
      if {[regexp {\{([\w.]+)\}\s+(.+)$} $lx all tag lxtail]} {
        endspec
        beginspec $tag $lxtail\n
      } elseif {[regexp {^COVENANTS:$} $lx]} {
        endspec
      } elseif {[regexp {^LIMITATIONS:$} $lx]} {
        endspec
      } else {
        append specbody $lx\n
      }
    } elseif {[string range $line 0 1]=="*/"} {
      endspec
      set phase 3
    }
  } elseif {$phase==3} {
    if {$line==""} {
      if {[regexp {\{([\w.]+)\}} $title all tag]} {
        set bx "The following C/C++ interfaces are defined:\n"
        append bx <blockquote><pre>\n"
        set code [string map {& &amp; < &lt; > &gt;} $code]
        append bx [string trim $code]\n
        append bx "</pre></blockquote"
        beginspec $tag $bx
        endspec
      }
      lappend content [list $key $title $type $kwlist $body $code]
      set title {}
      set keywords {}
      set type {}
      set body {}
      set code {}
      set phase 0
      set dcnt 0
    } else {
      if {[regexp {^#define (SQLITE_[A-Z0-9_]+)} $line all kx]} {
        set type constant
        set keyword($kx) 1
        incr dcnt
      } elseif {[regexp {^typedef .*(sqlite[0-9a-z_]+);} $line all kx]} {
        set type datatype
        set keyword($kx) 1
        incr dcnt
      } elseif {[regexp {^[a-z].*[ *](sqlite3_[a-z0-9_]+)\(} $line all kx]} {
        set type function
        set keyword($kx) 1
        incr dcnt
      } elseif {[regexp {^SQLITE_EXTERN .*(sqlite[0-9a-z_]+);} $line all kx]} {
        set type datatype
        set keyword($kx) 1
        incr dcnt
      }
      append code $line\n
    }
  }
}

# Convert a tag name into the filename used for the
# multi-file version.
#
# Constants begin with SQLITE_.  The names are converted
# to lower case and prefixed with "c_".  If we did not
# do this, then the names "SQLITE_BLOB" and "sqlite3_blob"
# would collide.
#
proc convert_tag_name {oldname} {
  set oldname [string tolower $oldname]
  regsub {^sqlite_} $oldname {c_} oldname
  regsub {^sqlite3_} $oldname {} name
  return $name.html
}

</tcl>

</table>
