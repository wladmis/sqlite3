# 2005 November 30
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#
# This file contains tests to ensure that the library handles malloc() failures
# correctly. The emphasis in this file is on sqlite3_column_XXX() APIs.
#
# $Id$

#---------------------------------------------------------------------------
# NOTES ON EXPECTED BEHAVIOUR
#
#---------------------------------------------------------------------------

set testdir [file dirname $argv0]
source $testdir/tester.tcl

# Only run these tests if memory debugging is turned on.
if {[info command sqlite_malloc_stat]==""} {
   puts "Skipping malloc tests: not compiled with -DSQLITE_MEMDEBUG..."
   finish_test
   return
}


proc do_stmt_test {id sql} {
  set ::sql $sql
  set go 1
  for {set n 1} {$go} {incr n} {
    set testid "malloc4-$id.(iFail $n)"

    # Prepare the statement
    do_test ${testid}.1 {
      set ::STMT [sqlite3_prepare $::DB $sql -1 TAIL]
      expr [string length $::STMT] > 0
    } {1}

    # Set the Nth malloc() to fail.
    sqlite_malloc_fail $n

    # Test malloc failure in the _name(), _name16(), decltype() and
    # decltype16() APIs. Calls that occur after the malloc() failure should
    # return NULL. No error is raised though.
    do_test ${testid}.2.1 {
      set mf1 [expr [lindex [sqlite_malloc_stat] 2] <= 0]
      set ::name8  [sqlite3_column_name $::STMT 0]
      set mf2 [expr [lindex [sqlite_malloc_stat] 2] <= 0]
      expr {$mf1 == $mf2 || $::name8 == ""}
    } {1}
    do_test ${testid}.2.2 {
      set mf1 [expr [lindex [sqlite_malloc_stat] 2] <= 0]
      set ::name16 [sqlite3_column_name16 $::STMT 0]
      set ::name16 [encoding convertfrom unicode $::name16]
      set ::name16 [string range $::name16 0 end-1]
      set mf2 [expr [lindex [sqlite_malloc_stat] 2] <= 0]
      expr {$mf1 == $mf2 || $::name16 == ""}
    } {1}
    do_test ${testid}.2.3 {
      set mf1 [expr [lindex [sqlite_malloc_stat] 2] <= 0]
      set ::name8_2 [sqlite3_column_name $::STMT 0]
      set mf2 [expr [lindex [sqlite_malloc_stat] 2] <= 0]
      expr {$mf1 == $mf2 || $::name8_2 == ""}
    } {1}
    set ::mallocFailed [expr [lindex [sqlite_malloc_stat] 2] <= 0]
    do_test ${testid}.2.4 {
      expr {
        $::name8 == $::name8_2 && $::name16 == $::name8 && !$::mallocFailed ||
        $::name8 == $::name8_2 && $::name16 == "" &&        $::mallocFailed ||
        $::name8 == $::name16 && $::name8_2 == "" &&        $::mallocFailed ||
        $::name8_2 == $::name16 && $::name8 == "" &&        $::mallocFailed
      }
    } {1}

    if {$::mallocFailed == 0} {
      sqlite_malloc_fail 0
      set go 0
    }

if 0 {
    # Test that if a malloc() failed the next call to sqlite3_step() returns
    # SQLITE_ERROR. If malloc() did not fail, it should return SQLITE_ROW.
    #
    # Before running sqlite3_step(), make sure that malloc() is not about to
    # fail. Memory allocation failures that occur within sqlite3_step() are
    # tested elsewhere.
    do_test ${testid}.3 {
      set rc [sqlite3_step $::STMT]
      list [expr $rc=="SQLITE_ERROR"] [expr $rc=="SQLITE_ROW"]
    } [list $mallocFailed [expr !$mallocFailed]]
}

    do_test ${testid}.4 {
      sqlite3_finalize $::STMT
    } {SQLITE_OK}
  }
}

execsql {
  CREATE TABLE tbl(
    the_first_reasonably_long_column_name that_also_has_quite_a_lengthy_type
  );
}
do_stmt_test 1 "SELECT * FROM tbl"

sqlite_malloc_fail 0
finish_test

