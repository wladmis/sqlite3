# 2005 December 30
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.  The
# focus of this file is testing the SELECT statement.
#
# $Id$

set ::enable_shared_cache [sqlite3_enable_shared_cache 1]

set testdir [file dirname $argv0]
source $testdir/tester.tcl
db close

ifcapable !shared_cache {
  finish_test
  return
}

# Test organization:
#
# shared-1.*: Simple test to verify basic sanity of table level locking when
#             two connections share a pager cache.
# shared-2.*: Test that a read transaction can co-exist with a 
#             write-transaction, including a simple test to ensure the 
#             external locking protocol is still working.
#

do_test shared-1.1 {
  # Open a second database on the file test.db. It should use the same pager
  # cache and schema as the original connection. Verify that only 1 file is 
  # opened.
  sqlite3 db2 test.db
  sqlite3 db  test.db
  set ::sqlite_open_file_count
} {1}
do_test shared-1.2 {
  # Add a table and a single row of data via the first connection. 
  # Ensure that the second connection can see them.
  execsql {
    CREATE TABLE abc(a, b, c);
    INSERT INTO abc VALUES(1, 2, 3);
  } db
  execsql {
    SELECT * FROM abc;
  } db2
} {1 2 3}
do_test shared-1.3 {
  # Have the first connection begin a transaction and obtain a read-lock
  # on table abc. This should not prevent the second connection from 
  # querying abc.
  execsql {
    BEGIN;
    SELECT * FROM abc;
  }
  execsql {
    SELECT * FROM abc;
  } db2
} {1 2 3}
do_test shared-1.4 {
  # Try to insert a row into abc via connection 2. This should fail because
  # of the read-lock connection 1 is holding on table abc (obtained in the
  # previous test case).
  catchsql {
    INSERT INTO abc VALUES(4, 5, 6);
  } db2
} {1 {database is locked}}
do_test shared-1.5 {
  # Using connection 2 (the one without the open transaction), create a 
  # new table and add a row to it. This is permitted as the transaction
  # started by connection 1 is currently a read transaction.
  execsql {
    CREATE TABLE def(d, e, f);
    INSERT INTO def VALUES('I', 'II', 'III');
  } db2
} {}
do_test shared-1.6 {
  # Upgrade connection 1's transaction to a write transaction. Insert
  # a row into table def - the table just created by connection 2.
  #
  # Connection 1 is able to see table def, even though it was created 
  # "after" the connection 1 transaction was started. This is because no
  # lock was established on the sqlite_master table.

# Todo: Remove this. Because the implementation does not include
# shared-schemas yet, we need to run some query (that will fail at 
# OP_VerifyCookie) so that connection 1 picks up the schema change
# made via connection 2. Otherwise the sqlite3_prepare("INSERT INTO def...")
# below will fail.
execsql {
  SELECT * FROM sqlite_master;
}

  execsql {
    INSERT INTO def VALUES('IV', 'V', 'VI');
  }
} {}
do_test shared-1.7 {
  # Read from the sqlite_master table with connection 1 (inside the 
  # transaction). Then test that we can no longer create a table 
  # with connection 2. This is because of the read-lock on sqlite_master.
  execsql {
    SELECT * FROM sqlite_master;
  }
  catchsql {
    CREATE TABLE ghi(g, h, i);
  } db2
} {1 {database is locked}}
do_test shared-1.8 {
  # Check that connection 2 can read the sqlite_master table. Then
  # create a table using connection 1 (this should write-lock the 
  # sqlite_master table). Then try to read sqlite_master again using 
  # connection 2 and verify that the write-lock prevents this.
  execsql {
    SELECT * FROM sqlite_master;
  } db2
  execsql {
    CREATE TABLE ghi(g, h, i);
  } 
  catchsql {
    SELECT * FROM sqlite_master;
  } db2
} {1 {database is locked}}
do_test shared-1.9 {
  # Commit the connection 1 transaction.
  execsql {
    COMMIT;
  }
} {}

do_test shared-2.1 {
  # Open connection db3 to the database. Use a different path to the same
  # file so that db3 does *not* share the same pager cache as db and db2
  # (there should be two open file handles).
  sqlite3 db3 ./test.db
  set ::sqlite_open_file_count
} {2}
do_test shared-2.2 {
  # Start read transactions on db and db2 (the shared pager cache). Ensure
  # db3 cannot write to the database.
  execsql {
    BEGIN;
    SELECT * FROM abc;
  }
  execsql {
    BEGIN;
    SELECT * FROM abc;
  } db2
  catchsql {
    INSERT INTO abc VALUES(1, 2, 3);
  } db2
} {1 {database is locked}}
do_test shared-2.3 {
  # Turn db's transaction into a write-transaction. db3 should still be
  # able to read from table def (but will not see the new row). Connection
  # db2 should not be able to read def (because of the write-lock).

# Todo: The failed "INSERT INTO abc ..." statement in the above test
# has started a write-transaction on db2 (should this be so?). This 
# would prevent connection db from starting a write-transaction. So roll the
# db2 transaction back and replace it with a new read transaction.
  execsql {
    ROLLBACK;
    BEGIN;
    SELECT * FROM abc;
  } db2

  execsql {
    INSERT INTO def VALUES('VII', 'VIII', 'IX');
  }
  concat [
    catchsql { SELECT * FROM def; } db3
  ] [
    catchsql { SELECT * FROM def; } db2
  ]
} {0 {I II III IV V VI} 1 {database is locked}}
do_test shared-2.4 {
  # Commit the open transaction on db. db2 still holds a read-transaction.
  # This should prevent db3 from writing to the database, but not from 
  # reading.
  execsql {
    COMMIT;
  }
  concat [
    catchsql { SELECT * FROM def; } db3
  ] [
    catchsql { INSERT INTO def VALUES('X', 'XI', 'XII'); } db3
  ]
} {0 {I II III IV V VI VII VIII IX} 1 {database is locked}}


catch {db close}
catch {db2 close}
catch {db3 close}

finish_test
sqlite3_enable_shared_cache $::enable_shared_cache

