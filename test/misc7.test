# 2006 September 4
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
# This file implements regression tests for SQLite library.
#
# $Id$

set testdir [file dirname $argv0]
source $testdir/tester.tcl

do_test misc7-1 {
  c_misuse_test
} {}

do_test misc7-2 {
  c_realloc_test
} {}

do_test misc7-3 {
  c_collation_test
} {}

# Try to open a directory:
#
do_test misc7-4 {
  file delete mydir
  file mkdir mydir
  set rc [catch {
    sqlite3 db2 ./mydir
  } msg]
  list $rc $msg
} {1 {unable to open database file}}

# Try to open a file with a directory where it's journal file should be.
#
do_test misc7-5 {
  file delete mydir
  file mkdir mydir-journal
  sqlite3 db2 ./mydir
  catchsql {
    CREATE TABLE abc(a, b, c);
  } db2
} {1 {unable to open database file}}
db2 close

#--------------------------------------------------------------------
# The following tests, misc7-6.* test the libraries behaviour when
# it cannot open a file. To force this condition, we use up all the
# file-descriptors before running sqlite. This probably only works
# on unix.
#

proc use_up_files {} {
  set ret [list]
  catch {
    while 1 { lappend ret [open test.db] }
  }
  return $ret
}

execsql { CREATE TABLE abc(a PRIMARY KEY, b, c); }
db close
set fd_list [use_up_files]
set ::go 1
set ::n 1
while {$::go} {
  catch {db close}
  do_test misc7-6.$::n {
    set rc [catch {
      sqlite db test.db
      db eval {
        BEGIN;
        INSERT INTO abc VALUES(1, 2, 3);
        INSERT INTO abc VALUES(2, 3, 4);
        INSERT INTO abc SELECT a+2, b, c FROM abc;
        COMMIT;
      }
    } msg]
    if {$rc == 0} {set ::go 0}

    expr {$rc == 0 || ($rc == 1 && $msg eq "unable to open database file")}
  } 1

  close [lindex $fd_list 0]
  set fd_list [lrange $fd_list 1 end]
  incr ::n
}
foreach fd $fd_list {
  close $fd
}
db close
#
# End of tests for out-of-file-descriptors condition.
#--------------------------------------------------------------------

#--------------------------------------------------------------------
# Test that the sqlite3_busy_timeout call seems to delay approximately
# the right amount of time.
#
do_test misc7-6 {
  sqlite3 db2 test.db
  sqlite3 db test.db
  sqlite3_busy_timeout [sqlite3_connection_pointer db] 2000
  execsql {
    BEGIN EXCLUSIVE;
  } db2

  # Now db2 has an exclusive lock on the database file, and db has
  # a busy-timeout of 2000 milliseconds. So check that trying to
  # access the database using connection db delays for at least 1500 ms.
  #
  set c1 [clock clicks -milliseconds]
  catchsql {
    SELECT * FROM sqlite_master;
  } db
  expr {([clock clicks -milliseconds]-$c1) > 1500 ? 1 : 0}
} {1}
db2 close

#--------------------------------------------------------------------
# Test that nothing goes horribly wrong when attaching a database
# after the omit_readlock pragma has been exercised.
#
do_test misc7-7.1 {
  file delete -force test2.db
  file delete -force test2.db-journal
  execsql {
    PRAGMA omit_readlock = 1;
    ATTACH 'test2.db' AS aux;
    CREATE TABLE aux.hello(world);
    SELECT name FROM aux.sqlite_master;
  }
} {hello}
do_test misc7-7.2 {
  execsql {
    DETACH aux;
  }
} {}

# Test malloc failure whilst installing a foriegn key.
#
ifcapable utf16 {
  do_test misc7-8 {
    encoding convertfrom unicode [sqlite3_errmsg16 0x00000000]
  } {out of memory}
}

do_test misc7-9 {
  execsql {
    SELECT * 
    FROM (SELECT name+1 AS one FROM sqlite_master LIMIT 1 OFFSET 1) 
    WHERE one LIKE 'hello%';
  }
} {}

#--------------------------------------------------------------------
# Improve reported coverage by running some debugging code:
#
ifcapable vtab {
  do_test misc7-10 {
    register_echo_module [sqlite3_connection_pointer db]
    set sqlite_where_trace 1
    execsql {
      CREATE VIRTUAL TABLE t1 USING echo(abc);
      SELECT a FROM t1 WHERE a = 1 ORDER BY b;
    }
  } {1}
}

finish_test
